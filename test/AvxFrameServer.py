# Automated testing framework for AvxSynth.
# Script execution and output handling.

import datetime
import hashlib
import os
import subprocess
import sys

from AvxTestCommon import *


class AvxFrameServer(object):
    '''AvxFrameServer:

    Evalues an AvxSynth script and computes hashsums of output
    '''
    def __init__(self, avs_name, extra_file_list=[]):
        '''Parameters:

        avs_name: pathname of script to open
        extra_file_list: list of additional files generated by script
        '''
        self.avs_name = avs_name
        self._dump_name = os.path.basename(avs_name) + '_AVDUMP'
        self._stderr_name = os.path.basename(avs_name) + '_STDERR'
        self.extra_file_list = extra_file_list
        self._clean_files = self.extra_file_list + [self._dump_name,
                                                    self._stderr_name]
        self._main_hash = None
        self._extra_hash_table = {}
        self.ready = True

    def run(self, dumpav=False, source_chdir='.', output_chdir='.'):
        '''Evalute script.  Check the status of self.ready first.'''
        if not self.ready:
            raise AvxNotReadyError('Subprocess already completed')
        if os.path.exists(output_chdir) & (not os.path.isdir(output_chdir)):
            raise ValueError('{} is not a directory'.format(output_chdir))
        if not os.path.exists(output_chdir):
            os.mkdir(output_chdir)
        orig_path = os.getcwd()
        source_abs_path = os.path.realpath(source_chdir)
        output_abs_path = os.path.realpath(output_chdir)

        # Change these as needed.
        BUFSIZE = 4 * 2 ** 20
        MAXSIZE = 1 * 2 ** 30
        MAXTIME = datetime.timedelta(seconds=600)

	avsfile = source_abs_path + '/' + self.avs_name
        errlog = open(output_abs_path + '/' + self._stderr_name, mode='wb')
        try:
            process = subprocess.Popen(
                ['avxFrameServer', avsfile, 'N'],
#                ['avs2pipemod', avsfile, '-rawvideo'],
                bufsize=BUFSIZE, stdout=subprocess.PIPE, stderr=errlog)
        except OSError as err:
            raise AvxScriptError(err)        
        start_time = datetime.datetime.now()
        hashsum = hashlib.md5()

        os.chdir(output_abs_path)
        if dumpav:
            dump = open(self._dump_name, 'wb')
        read_bytes = 0
        while process.poll() == None:
            buf = process.stdout.read(BUFSIZE)
            if dumpav:
                dump.write(buf)
            read_bytes += len(buf)
            hashsum.update(buf)
            if read_bytes > MAXSIZE:
                process.terminate()
                errmsg = 'More data than maximum of {0} was produced'
                raise AvxRuntimeError(errmsg.format(MAXSIZE))
            if datetime.datetime.now() - start_time > MAXTIME:
                process.terminate()
                errmsg = 'Script taking longer than maximum of {0} to execute'
                raise AvxRuntimeError(errmsg.format(MAXTIME))
        # The process will terminate if less than BUFSIZE bytes remain
        buf = process.stdout.read()
        if dumpav:
            dump.write(buf)
            dump.close()
        hashsum.update(buf)
        errlog.close()
        if process.returncode != 0:
            raise AvxRuntimeError('Script returned nonzero exit status')
        self._main_hash = hashsum.hexdigest()
        for i in self.extra_file_list:
            try:
                file = open(i, 'rb')
                self._extra_hash_table[i] = hashlib.md5(file.read()).hexdigest()
                file.close()
            except IOError as err:
                errmsg = 'Extra file {0} was not found'
                raise AvxFileError(errmsg.format(i))
        # Change back to the original path before returning.
        os.chdir(orig_path)

        self.ready = False
        
    def query_results(self):
        '''Return a tuple of the main output hash and a dict of the hashes
        of all the additional files in self.extra_file_list.  Check the status
        of self.ready first.
        '''
        if self.ready:
            raise AvxNotReadyError('Subprocess has not yet executed')
        return self._main_hash, self._extra_hash_table

    def cleanup(self, output_chdir='.'):
        '''Delete generated files listed in self.extra_file_list and reset
        self.ready'''
        orig_path = os.getcwd()
        try:
            os.chdir(output_chdir)
        except OSError:
            pass
        for i in self._clean_files:
            if os.path.isfile(i):
                try:
                    os.unlink(i)
                except OSError:
                    errmsg = 'Auto-generated file {0} was not deleted\n'
                    sys.stderr.write(errmsg.format(i))
        os.chdir(orig_path)

        self._main_hash = None
        self._extra_hash_table = {}
        self.ready = True
